{\rtf1\ansi\ansicpg1252\cocoartf1187
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww27680\viewh17220\viewkind0
\deftab720
\pard\pardeftab720\sa240

\f0\fs32 \cf0 Duy Vo 301130583
\fs24 \

\fs32 Based on the 10 benchmarks used in the testing, Python overall performed much better than Scala for small, simple, but memory intensive programs such as calculating the digits of pi. It generally uses much less memory and code to achieve the functions desired. This definitely could lead to huge multi-tasking potential! Thus, other than for people in the mathematic or scientific field, beginner, intermediates, and experts should all consider using python for its simplicity, readability, and reliability.
\fs24 \

\fs32 Using the 10 benchmark program  shown, Python bested Scala handily in terms of  memory usage and code length. There\'92s really no contest here. In 6 out of the 10 benchmark programs, Python used far less memory then Scala, ranging anywhere between 1/3rd to even 1/8
\fs22 \up16 th 
\fs32 \up0  the amount needed. Most of the programs were ________ It's also interesting to note that out of the 4 benchmarks that python did lose, the memory ratio never ranged more than 1/3
\fs22 \up16 rd
\fs32 \up0  or 33% more. These programs were _________ centric. That is certainly impressive. \
Now, in terms of actual code length, Python 3 again wins hands down. Again, winning 6/10 benchmarks, the lengths of the code ranged from 1\uc0\u8260 4 to 1\u8260 2 compared to Scala, there is no questioning that python is much easier to write code with. It\'92s not only shorter, but also easier. I know for a fact that syntaxes are much more forgiving. How much do you want to wrestle with the coding process instead of actually the problem.
\fs24 \

\fs32 Out of the two languages, Python is the king when comparing memory usage and code length in a SINGLE core environment. Even comparing to all the other languages, it usually ranges in the top 15 for both values. Now, it does have one major weakness, and that is execution time. Pure, hard number crunching is definitely not its strong point. Scala wins this one, but even looking in the big picture, it\'92s not pretty. Python is in the last worst 10 spots for longest amount of seconds on average based on the 10 benchmark tests. Phew, now that\'92s out of
\fs24 \

\fs32 the way. Looking at start-up time and cost though, there\'92s no shame in these numbers. Python, as expected, beats Scala in both.Interestingness: These benchmarks tests are very important, but they\'92re not be-all end-all. The algorithms here, for the most part, are rarely used (except binary tree perhaps) unless you\'92re specialized in one of the Biology or math. I mean, calculating pi? Nucleotides? DNA sequence? You\'92re not going to find these every day in the industry. These results might disappoint some people but it really shouldn\'92t. You\'92re exchanging a bit of runtime for much easier coding and less memory. Your computer will thank you as you try to play your music, chat with yours friends, explore the internet, and code at the same time. There\'92s a reason why python is much more widely used than Scala. Look at the amount of programs that were contributed to the benchmark site and you\'92ll see that Phython comes in FIRST with 
\fs30 12.2 submissions. 
\fs32 Also, these tests are run on single cores. It\'92s pretty normal for people to run QUAD-cores, which means that python actually benefits the most in terms of seconds difference!
\fs24 \

\fs32 Credibility: The benchmark tests are important, and are fairly reliable. They\'92ve been tested in controlled experiments, using the same computer specs and environment throughout. Having said that, the benchmarks are also only using single cores to get the results. In today\'92s time and place, most if not all computers use dual-cores at least, if not quad-cores. Also, there\'92s really no measurement on ease of coding and usage. I mean, if a language is 3x more difficult to code just to a 1.5x advantage in runtime, is that really worth it? It\'92s not documented at all, but I can see why it isn\'92t. In terms of fairness, the benchmarks are as fair as can be as started above. They are in controlled environments with only one difference: the language used. Now comes the big question: do the things measured matter at all? Not in real life application, no. You\'92ll rarely find yourself in situations where you\'92re just trying to crunch this really complex algorithm. Real world applications are often much simpler. Thus, the CPU time criteria is not as important. The memory usage and code length can be applied more handily though. No matter the size of the code, those 2 traits will apply and have very visible effects during the programming process.
\fs24 \

\fs32 Good things to note:
\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240
\ls1\ilvl0
\fs32 \cf0 		- \'a0Less memory usage = can multi-task, run multiple programs at once 
\fs24 \
\ls1\ilvl0
\fs32 		- \'a0Less downtime as you code next program while you wait for results from 1
\fs22 \up16 st 
\fs32 \up0 program 
\fs24 \
\ls1\ilvl0
\fs32 		- \'a0Code length is not linear relationship. Code that is 10x longer can possibly take more 
\fs24 \uc0\u8232 
\fs32 than 10 times as long to code due to having much more variables, syntax, and manegment 
\fs24 \
\ls1\ilvl0
\fs32 		- \'a0Easier syntax/coding means easier to read, easier to code properly 
\fs24 \
\ls1\ilvl0
\fs32 		- \'a0Lower learning curve, more people can code complex things 
\fs24 \
\pard\pardeftab720\sa240

\fs32 \cf0 http://shootout.alioth.debian.org
\fs24 \

\fs32 Reference:
\fs24 \
}